# B-Tree

## 简介
- B树是为磁盘或者其他直接存取的辅助存储设备设计的平衡搜索树
- 和红黑树的区别是B树的节点可以有很多孩子, 就是说一棵树的分支因子可以很大. 
- 因此Btree相较于RBTree的高度很低
- 如果节点内有x.n个关键字, 那么x的孩子数就是x.n + 1
- 节点中的关键字可以看作是分割点, 把x种所处理的关键字的属性分割为x.n+1个域, 每个域都有x的一个孩子处理
- 当在一个B树中查找一个关键字时, 基于对存储在x中的x.n个关键字的比较, 做出一个x.n + 1路的选择

## 和磁盘的关系

- 为什么针对磁盘设计的数据结构不同于针对随机访问主存设计的数据结构?
  - 主存(内存)访问速度很快, 磁盘(辅存)访问的速度很慢(IO)

- 磁盘驱动器: 
  - 由一个或者多个盘片以一定速度绕着主轴旋转, 每个盘的表面覆盖一层可以磁化的物质, 驱动器通过磁臂末尾的磁头来读取/写入. 
  - 磁臂可以绕主轴离近离远, 当磁臂静止的时候, 下面经过的磁盘表面叫做磁道
  - 信息被分为一系列相等大小的在柱面内连续出现的位页面, 并且磁盘一次读取一个页面

- 在B Tree App中, 要处理的数据量非常大, 以至于所有数据无法一次性装入主存, B树算法将所需页面从磁盘恢复到主存, 然后将修改过的页面写回磁盘. 任何时刻主存中要保存一定数量的页面, 主存的大小并不限制被处理的Btree的大小. 

- 从磁盘中加载对象
```
x = a point to some object
DISK-READ(x);
operation that accress and/or modify the attributes of x
DISK-WRITE(x);
operation that accress and/or modify the attributes of x
```

- B-Tree的算法的时间主要由Disk-read(), Disk-write()所决定
- 所谓分支因子就是树的叉有多少. 

## 定义
1. 每个节点x有下面的属性
   1. x.n, 当前存储在x中的关键字个数
   2. x.n 个关键字本身x.key1, x.key2, ..., x.keyn 用非降序方式存放. `(x.key(1) <= x.key(2) <= ... <= x.key(n))` 
   3. x.leaf 是一个bool值, 如果x是叶节点, 就是true, 否则就是false
2. 每个内部节点还包括 x.n + 1个指向其孩子的指针`x.c(1), x.c(2), x.c(3), ...., x.c(n+1)`, 叶节点没有孩子, 因此他们的ci未定义. 
3. 关键字x.keyi对存储在各子树中的关键字范围加以分割, 用ki, 来表示ci为根的子树的关键字那么  
   `k(1) <= x.key(1) <= key(2) <= x.key(2) <= .... <= x.key(n) <= k(x.n + 1)`
4. 每个叶节点有相同的深度: 就是树的高度h
5. 每个关键字个数有上界和下界, 用一个被称为b树的最小度数t(t >= 2) 来表示
   1. 除了根节点, 每个节点至少有t - 1个关键字, 因此除了根节点以外每个内部节点至少有t个孩子
   2. 每个节点至多可以包含2t - 1个关键字, 因此一个内部节点最多可以有2t个孩子. 当一个节点有2t - 1个关键字, 那这个节点是满的(full)
