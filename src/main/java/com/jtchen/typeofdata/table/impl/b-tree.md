# B-Tree

## 简介
- B树是为磁盘或者其他直接存取的辅助存储设备设计的平衡搜索树
- 和红黑树的区别是B树的节点可以有很多孩子, 就是说一棵树的分支因子可以很大. 
- 因此Btree相较于RBTree的高度很低
- 如果节点内有x.n个关键字, 那么x的孩子数就是x.n + 1
- 节点中的关键字可以看作是分割点, 把x种所处理的关键字的属性分割为x.n+1个域, 每个域都有x的一个孩子处理
- 当在一个B树中查找一个关键字时, 基于对存储在x中的x.n个关键字的比较, 做出一个x.n + 1路的选择

## 和磁盘的关系

- 为什么针对磁盘设计的数据结构不同于针对随机访问主存设计的数据结构?
  - 主存(内存)访问速度很快, 磁盘(辅存)访问的速度很慢(IO)

- 磁盘驱动器: 
  - 由一个或者多个盘片以一定速度绕着主轴旋转, 每个盘的表面覆盖一层可以磁化的物质, 驱动器通过磁臂末尾的磁头来读取/写入. 
  - 磁臂可以绕主轴离近离远, 当磁臂静止的时候, 下面经过的磁盘表面叫做磁道
  - 信息被分为一系列相等大小的在柱面内连续出现的位页面, 并且磁盘一次读取一个页面

- 在B Tree App中, 要处理的数据量非常大, 以至于所有数据无法一次性装入主存, B树算法将所需页面从磁盘恢复到主存, 然后将修改过的页面写回磁盘. 任何时刻主存中要保存一定数量的页面, 主存的大小并不限制被处理的Btree的大小. 

- 从磁盘中加载对象
```
x = a point to some object
DISK-READ(x);
operation that accress and/or modify the attributes of x
DISK-WRITE(x);
operation that accress and/or modify the attributes of x
```

- B-Tree的算法的时间主要由Disk-read(), Disk-write()所决定
- 所谓分支因子就是树的叉有多少. 

## 定义
1. 每个节点x有下面的属性
   1. x.n, 当前存储在x中的关键字个数
   2. x.n 个关键字本身x.key1, x.key2, ..., x.keyn 用非降序方式存放. `(x.key(1) <= x.key(2) <= ... <= x.key(n))` 
   3. x.leaf 是一个bool值, 如果x是叶节点, 就是true, 否则就是false
2. 每个内部节点还包括 x.n + 1个指向其孩子的指针`x.c(1), x.c(2), x.c(3), ...., x.c(n+1)`, 叶节点没有孩子, 因此他们的ci未定义. 
3. 关键字x.keyi对存储在各子树中的关键字范围加以分割, 用ki, 来表示ci为根的子树的关键字那么  
   `k(1) <= x.key(1) <= key(2) <= x.key(2) <= .... <= x.key(n) <= k(x.n + 1)`
4. 每个叶节点有相同的深度: 就是树的高度h
5. 每个关键字个数有上界和下界, 用一个被称为b树的最小度数t(t >= 2) 来表示
   1. 除了根节点, 每个节点至少有t - 1个关键字, 因此除了根节点以外每个内部节点至少有t个孩子
   2. 每个节点至多可以包含2t - 1个关键字, 因此一个内部节点最多可以有2t个孩子. 当一个节点有2t - 1个关键字, 那这个节点是满的(full)

- ⭐ fun-fact: 红黑树对于每个节点: 吸收红色孩子节点, 并且把红色节点的孩子变成自己的孩子, 将会变成一个t = 2 的 b-tree

## b-tree的基本操作

- 两个约定
   1. B-tree的根节点一直在主存中, 这样无需对根节点进行DISK-READ操作. 但是当根节点被改变的时候要做一次DISK-WRITE操作
   2. 任何被当作参数的节点被传递之前, 都要进行DISK-READ操作

### b-tree的搜索
- 线性搜索: 
- B-TREE-SEARCH(x, k) (从key1开始, 下标为1开始)
   ```
   i = 1;
   while (i <= x.n && x.key(i) < k)
      i = i + 1;
   if (i <= x.n && x.key(i) == k) 
      return (x, i);
   else if (x.leaf) 
      return NIL;
   else {
      DISK-READ(x, c(i));
      return B-TREE-SEARCH(x.c(i), k);
   }

   ```
- 利用线性搜索, 时间复杂度是O(tlog(t)n)/O(th)

### b-tree的创建. 
- B-TREE-CREATE(T)
   ```
   x = ALLOCATE-NODE()
   x.leaf = true;
   x.n = 0;
   DISK-WRITE(x);
   T.root = x;
   ```
### b-tree 的插入
- 不能简单的创建一个新的节点然后插入. 这会破坏b-tree的性质. 
- 也不能将关键词插入到满了的b-tree之中
- 因此在插入之前如果是满的要进行分裂, 把2t - 1分为两个t - 1和一个中间关键字, 中间关键字上升至父节点
- 我们并不是等到找出插入过程中实际要分裂的满节点才做分裂, 相反, 当沿着树往下查找新的关键字所属的位置的时候, 就分裂沿途遇到的满节点
- 因此要分裂一个节点y时能确保它父亲不是满的


### b-tree的分裂


## 磁盘管理/CS模型参考
- https://medium.com/@pthtantai97/implement-key-value-store-by-btree-5a100a03da3a